import{_ as s,r as a,c as r,a as e,b as t,t as i,d as l,F as d,e as c,o as h}from"./app.6f02f33f.js";const p={},u={id:"frontmatter-title",tabindex:"-1"},f=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),g=e("h2",{id:"bbr\u662F\u4E2A\u4EC0\u4E48\u4E1C\u897F",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#bbr\u662F\u4E2A\u4EC0\u4E48\u4E1C\u897F","aria-hidden":"true"},"#"),t(" BBR\u662F\u4E2A\u4EC0\u4E48\u4E1C\u897F\uFF1A")],-1),b=e("p",null,"TCP BBR\uFF08Bottleneck Bandwidth and Round-trip propagation time\uFF09\u662F\u7531Google\u8BBE\u8BA1\uFF0C\u4E8E2016\u5E74\u53D1\u5E03\u7684\u62E5\u585E\u7B97\u6CD5\u3002 \u4EE5\u5F80\u5927\u90E8\u5206\u62E5\u585E\u7B97\u6CD5\u662F\u57FA\u4E8E\u4E22\u5305\u6765\u4F5C\u4E3A\u964D\u4F4E\u4F20\u8F93\u901F\u7387\u7684\u4FE1\u53F7\uFF0C\u800CBBR\u5219\u57FA\u4E8E\u6A21\u578B\u4E3B\u52A8\u63A2\u6D4B\u3002 \u8BE5\u7B97\u6CD5\u4F7F\u7528\u7F51\u7EDC\u6700\u8FD1\u51FA\u7AD9\u6570\u636E\u5206\u7EC4\u5F53\u65F6\u7684\u6700\u5927\u5E26\u5BBD\u548C\u5F80\u8FD4\u65F6\u95F4\u6765\u521B\u5EFA\u7F51\u7EDC\u7684\u663E\u5F0F\u6A21\u578B\u3002 \u6570\u636E\u5305\u4F20\u8F93\u7684\u6BCF\u4E2A\u7D2F\u79EF\u6216\u9009\u62E9\u6027\u786E\u8BA4\u7528\u4E8E\u751F\u6210\u8BB0\u5F55\u5728\u6570\u636E\u5305\u4F20\u8F93\u8FC7\u7A0B\u548C\u786E\u8BA4\u8FD4\u56DE\u671F\u95F4\u7684\u65F6\u95F4\u5185\u6240\u4F20\u9001\u6570\u636E\u91CF\u7684\u91C7\u6837\u7387\u3002",-1),_=e("p",null,"Google\u5728YouTube\u4E0A\u5E94\u7528\u8BE5\u7B97\u6CD5\uFF0C\u5C06\u5168\u7403\u5E73\u5747\u7684YouTube\u7F51\u7EDC\u541E\u5410\u91CF\u63D0\u9AD8\u4E864%\uFF0C\u5728\u4E00\u4E9B\u56FD\u5BB6\u8D85\u8FC7\u4E8614%\u3002 \u6839\u636E\u5B9E\u5730\u6D4B\u8BD5\uFF0C\u5728\u90E8\u7F72\u4E86\u6700\u65B0\u7248\u5185\u6838\u5E76\u5F00\u542F\u4E86 TCP BBR \u7684\u673A\u5668\u4E0A\uFF0C\u7F51\u901F\u751A\u81F3\u53EF\u4EE5\u63D0\u5347\u597D\u51E0\u4E2A\u6570\u91CF\u7EA7\u3002",-1),m={href:"https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster",target:"_blank",rel:"noopener noreferrer"},B=t("\u5B98\u65B9\u4ECB\u7ECD"),k=c('<h2 id="\u8BBE\u8BA1\u601D\u60F3" tabindex="-1"><a class="header-anchor" href="#\u8BBE\u8BA1\u601D\u60F3" aria-hidden="true">#</a> \u8BBE\u8BA1\u601D\u60F3\uFF1A</h2><p>\u4E3B\u8981\u662F\u9488\u5BF9\u5927\u5E26\u5BBD\uFF0C\u6D45 buffer\uFF08\u6211\u7684\u7406\u89E3\u662F\u5E26\u5BBD\u5927\u4E86\u6DF1\u4E0D\u8D77\u6765\uFF09\u7684\u73B0\u4EE3\u4E92\u8054\u7F51\u573A\u666F\u8BBE\u8BA1</p><ul><li><p>\u7406\u89E3\u63D0\u5347\uFF1A \u4E4B\u524D\u7684\u57FA\u4E8E loss \u7684 CC \u4E5F\u662F\u5408\u7406\u7684\uFF0C\u5904\u7406\u4E86\u5F53\u65F6 99%\u7684\u60C5\u51B5\uFF1B\u800C\u4ECA\uFF0C\u57FA\u7840\u4E0D\u540C\u540E\uFF0C\u65B0\u7684 99%\u60C5\u51B5\u4E5F\u4E0D\u540C\uFF0C\u6240\u4EE5\u9700\u8981\u53E6\u5916\u4E00\u79CD\u65B9\u6CD5\u6765\u5904\u7406\uFF1B\u53EF\u80FD\u4E4B\u540E\uFF0C99%\u7684\u60C5\u51B5\u53C8\u4E0D\u540C\u4E86\uFF0C\u8FD8\u4F1A\u6709\u65B0\u7684\u65B9\u6CD5\u7684\uFF1B\u6240\u4EE5\u6301\u7EED\u5730\u7EDF\u8BA1\u3001\u89C2\u5BDF\u8FD9\u4E2A\u62E5\u585E\u60C5\u51B5\uFF0C\u624D\u80FD\u505A\u9AD8\u5C42\u8BBE\u8BA1</p></li><li><p>\u7406\u89E3\u63D0\u5347\uFF1A \u4E4B\u524D\u7684\u57FA\u4E8E loss \u7684 CC \u4E5F\u662F\u5408\u7406\u7684\uFF0C\u5904\u7406\u4E86\u5F53\u65F6 99%\u7684\u60C5\u51B5\uFF1B\u800C\u4ECA\uFF0C\u57FA\u7840\u4E0D\u540C\u540E\uFF0C\u65B0\u7684 99%\u60C5\u51B5\u4E5F\u4E0D\u540C\uFF0C\u6240\u4EE5\u9700\u8981\u53E6\u5916\u4E00\u79CD\u65B9\u6CD5\u6765\u5904\u7406\uFF1B\u53EF\u80FD\u4E4B\u540E\uFF0C99%\u7684\u60C5\u51B5\u53C8\u4E0D\u540C\u4E86\uFF0C\u8FD8\u4F1A\u6709\u65B0\u7684\u65B9\u6CD5\u7684\uFF1B\u6240\u4EE5\u6301\u7EED\u5730\u7EDF\u8BA1\u3001\u89C2\u5BDF\u8FD9\u4E2A\u62E5\u585E\u60C5\u51B5\uFF0C\u624D\u80FD\u505A\u9AD8\u5C42\u8BBE\u8BA1</p></li></ul><h2 id="\u4EE5\u4E0B\u539F\u6587" tabindex="-1"><a class="header-anchor" href="#\u4EE5\u4E0B\u539F\u6587" aria-hidden="true">#</a> \u4EE5\u4E0B\u539F\u6587</h2><p>What is BBR?</p><p>BBR (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) is a new congestion control algorithm developed at Google. Congestion control algorithms \u2014 running inside every computer, phone or tablet connected to a network \u2014 that decide how fast to send data. How does a congestion control algorithm make this decision? The internet has largely used loss-based congestion control since the late 1980s, relying only on indications of lost packets as the signal to slow down. This worked well for many years, because internet switches\u2019 and routers\u2019 small buffers were well-matched to the low bandwidth of internet links. As a result, buffers tended to fill up and drop excess packets right at the moment when senders had really begun sending data too fast.</p><p>But loss-based congestion control is problematic in today&#39;s diverse networks:</p><p>In shallow buffers, packet loss happens before congestion. With today&#39;s high-speed, long-haul links that use commodity switches with shallow buffers, loss-based congestion control can result in abysmal throughput because it overreacts, halving the sending rate upon packet loss, even if the packet loss comes from transient traffic bursts (this kind of packet loss can be quite frequent even when the link is mostly idle). In deep buffers, congestion happens before packet loss. At the edge of today&#39;s internet, loss-based congestion control causes the infamous \u201Cbufferbloat\u201D problem, by repeatedly filling the deep buffers in many last-mile links and causing seconds of needless queuing delay.</p>',8);function w(o,y){const n=a("ExternalLinkIcon");return h(),r(d,null,[e("h1",u,[f,t(" "+i(o.$frontmatter.title),1)]),g,b,_,e("p",null,[e("a",m,[B,l(n)])]),k],64)}var x=s(p,[["render",w],["__file","TCP-BBR-\u662F\u4E2A\u4EC0\u4E48\u73A9\u610F\u513F.html.vue"]]);export{x as default};
